# 아키텍처 설계

>### 계층형 아키텍처 (layered architecture pattern)

계층형 아키택처 패턴은 복잡한 시스템을 별도의 계층으로 나누는 데 활용하는 일반적인 기술이다

각 계층은 자체의 <u>관심사에 중점</u>을 둔다. 일<u>반적으로 구분에는 프레젠테이션 계층, 비지니스 계층, 데이터 접근 계층과 같 은 계층을 활용한다

상위 계층은 하위 계층에 의존하지만, 하위 계층은 자신을 의존하는 상위 계층의 존재를 인식하지 못한다.</u> 엄격한 계층형 아키텍처에서

상위 계층은 하위 계층에만 직접 의존할 수 있다. 느슨한 계층형 아키텍처에서 상위 계층은 아래의 모든 계층에 의존할 수 있다

- TIP
- 때로는 비지니스 계층을 애플리케이션 계층이나 서비스 계층, 도메인 계층이라고 부른다. 또는 애플리케이션 계층과 서비스 계층으로 나누어
4계층형 구조로 만들 수 도 있다. 계층의 이름이 무엇이든 상관없이 이 애플리케이션의 비즈니스 로직을 포함한다
 
![img](./계층형%20아키텍처.png)

대부분 요청이 데이터베이스에서 데이터를 읽거나 데이터를 다시 데이터베이스에 저장하는 데 관한 비즈니스 규칙이

조금 있는 애플리케이션에서 이 아키텍처가 적합하다. 이러한 애플리케이션에서 엔티티와 같은 도메인 모델은

게터와 세터를 가진 POJO 다 도메인 모델은 도메인 로직을 포함하지 않는다. 모델에 도메인 논리가 없어야 한다고 말하는

설계 규칙이 종종 있다. <u>대신 도메인 로직을 비즈니스 계층의 서비스 객체에 넣어야 한다</u> 이러한 도메인 모델을 일반적으로

빈약한 도메인 모델 (anermic domain models) 이라고 부른다.

이 데이터 중심 설계의 증상 중 하나는 애플리케이션의 복잡성이 커지면서 도메인 로직이 다른 계층으로

누출되는 것을 쉽게 볼 수 있다는 것이다. 다음 코드와 같이 무료 평가판 사용자를 활성화하는 간단한 예제를 살펴보자

```java
public class UserController {
    @PostMapping("/users/{userId}/activate")
    public void activate(@PathVariable(value="userId") int userId){
        user.setActive(true);
        user.setInFreeTrial(true);
        user.setFreeTrialEndDate(trialEndDate);
        user.setLastModifiedDate(now);
        userService.save(user);
        sendFreeTrialStartedEmail(user);
    }
}
```

보다 시피 activate() 메소드에서 세터를 활용해 user 엔티티를 수정한 다음 userService 에 변경 사항을 저장하도록 요청하고 사용자에 무료 평가판의 시작을 알리는 이메일을 보낸다.

더 나은 구현은 UserService API 에 activate() 메소드를 추가하고 세터를 이동시켜 이메일 로직을 해당 메소드로 보낸 후 UserController 를 다음과 같이 변경하는 것이다.

```java
public class UserController {
    @PostMapping("/users/{userId}/activate")
    public void activate(@PathVariable(value="userId") int userId){
       userService.activate(user);
    }
}
```

이 설계에는 여전히 잠재적이고 심각한 이슈가 있다.
보다시피 User 엔티티는 acttive 와 inFreeTrial 라는 두 개의 필드를 가진다.

사용자가 무표 평가판을 시작하려고 할 때 두 필드는 true 로 설정돼야 한다.

이런 상황을 상상해보자. 어느 날 이 로직에 익숙하지 않은 또 다른 개발자인 프랭크가 모바일 앱 사용자가 기능 명세서를 읽지 않고 등록할 수 있는 새로운 API 를 

만든다고 하자. 그는 아마 애자일 팀이라서 설계는 포괄적인 명세가 아닌 사용자 스토리일 가능성이 높다.

어쨌든, <u>프랭크는 새롭게 등록된 사용자가 활동 중일 때 inFreeTrial 필드가 true 로 설정돼야 한다는 것을 모른다. 이렇게 해서 심각한 버그가 유입됐다.</u>

희망적인 것은 QA팀은 이 버그를 배포하기 이전에 잡아낼 것이라는 점이다.


<u>사실 이 예제에서 계층형 아키택처를 활용한 것이 이러한 종류의 문제를 야기한 것은 아니다.

그러나 요점은 계층형 아키텍처는 개발자가 도메인 모델 관점이 아니 데이터 관점에서 시스템을 바라보게 하는 경향이 있다는 것이다</u>

>### 헥사고날 아키텍처

헥사고날 아키텍처는 사용자, 프로그램, 자동화 된 테스트 또는 배치 스크립트로 애플리케이션을 동일하게 구동할 수 있게 하며,
최종 런타임 장치 및 데이터베이스와 분리하여 애플리케이션을 개발하고 테스트 할 수 있도록 한다

![img](./헥사고날%20아키텍처.jpg)

이전 다이어그램에서 보다시피 가운데에 애플리케이션의 핵심이 있다. 그것은 모든 비즈니스 로직을 포함하고

경계를 만든다. 그리고 그 중심부에는 도메인 모델이 있다. 도메인 모델은 빈약하지 않은 풍부한 행동의 도메인 모델을 포함한다.

해당 애플리케이션 중심부 주위에 다이어그램의 어댑터와 같이 다른 포트에 도착한 외부 이벤트를 애플리케이션 핵심부에 대한 API 호출로 변환하는 어댑터가 있다

다이어그램의 모든 화살표는 단방향으로 어떤 상호작용이 어느 측면에서 트리거됐는지를 나타낸다. 이것은 상호작용이 단방향임을 의미하지 않는다.

<u>헥사고날 아키텍처는 도메인 주도 설계(DDD) 에 적합하다</u> 그것은 데이터베이스, 검색엔진, 메세지 큐

메일전송, <u>캐시 시스템과 같은 인프라에서 도메인 로직을 분리한다. 그것은 다양한 유형의 클라이언트를 쉽게 지원하도록 확장 할 수 있다.

거기에 새 어댑터를 추가하면 된다</u>