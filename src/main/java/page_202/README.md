# 코드 설계

> ###코드 설계의 단계

잭 리브스는 그의 글 `What Is Software Desgin: 13 Years Later` 에서 설계의 세 가진 단계를 언급했다.

_나는 좋은 아키텍처(최상위 수준의 설계), 좋은 추상화(클래스 설계), 그리고 좋은 구현(하위 수준의 설계)이 필요하다고 말하고 싶다_

여기에서는 이 내용을 `아키텍처 단계의 설계`, `추상화 단계의 설계`, 그리고 `구현 단계의 설계`로 바꾸어 다시 설명할 것이다

<br>

- **아키텍처 단계**  
    - 시스템이 멀티 레이어 설계를 사용하는가?
    - 모놀리식 서비스인가, 아니면 마이크로 서비스를 사용하는가?
    - 서브 시스템(subsystem)은 무엇이며 SOAP이나 REST, AMQP 를 사용해 어떻게 통신하는 가?
    - 서드파티 시스템과의 상호작용이 있는가? 서스파티 시스템과 어떻게 통신하는가?

<br>

이 단계의 설계는 기본적이고 대부분 아키텍처 설계를 초기에 수행한다. 일단 아키텍처 설계가 완료되면 근본적으로 잘못된 것이 있거나

이 단계에서 재설계 없이는 요구 사항 변경에 대한 구현이 불가능하지않다면 변경해서는 안된다.

아키텍처 주변에 상당한 양의 코드가 있으면 소스 코드를 통해 아키텍처 단계의 설계를 파악하는 것이 어렵고 거의 불가능하기 때문에 아키텍처 단계를 설계문서에 작성한다.

<br>

- **추상화 단계**

이 단계에서 설계는 서브 시스템의 패키지와 주요 컴포넌트에 중점을 두고 있으며 상위 수준의 설계로 유지돼야 한다.

비교적 간단하다면 일반적으로 설계 문서 또는 패키지 info.java 클래스에 유지한다.

이 단계의 설계는 서브 시스템의 추상적인 개요를 제공한다. <u>설계에는 핵심 클래스와 핵심 클래스 간의 관계만 포함시켜야 한다

가능하면 다른 세부사항은 포함하지 않아야 한다. 추상화 단계의 설계를 봤을 때 서브 시스템의 구조와 주요 로직을 이해할 수 있어야 한다 (=인터페이스 구현)</u>

서브 시스템의 구현을 시작할 때 추상화 단계의 설계를 수행한다. 일반적으로 이 단계의 설계는 안정적이다. 구현 중에

애플리케이션의 로직에 대해 더 많은 통찰력을 얻으면 추상화 단계의 설계를 향상 시킬 수 있다.

그러나 자주 변경할 일이 있어서는 안된다. 그렇지 않다면 설계 자체에 문제가 있는 것이다.

<br>

- **구현 단계**

<u>이 단계에서 설계는 클래스, 주로 필드와 메소드의 구현에 중점을 둔다.

구체적이고 하위 수준의 세부사항을 채운다 (=추상화 단계 클래스를 구현한다)</u>

소스 코드는 구현 단계에서 설꼐의 주요 표현이다.

복잡한 로직에 대한 UML 다이어그램을 만들 수도 있지만, 세부사항이 (사실 많이) 변하기 때문에 최소한으로 유지해야 한다
   
<br>

> 나쁜 설계의 증상

|증상|내용|
|---|---|
|경직성(Rigidity)|시스템을 변경하기 어렵다. 변경하려면 시스템의 다른 부분까지 많이 변경해야 하기 때문이다|
|취약성(Fragility)|변경하면 시스템에서 그 부분과 개념적으로 아무런 관련이 없는 부분이 망가진다|
|부동성(Immobility)|시스템을 다른 시스템에서 재사용할 수 있는 컴포넌트로 구분하기 어렵다|
|점착성(Viscosity)|옳은 동작을 하는 것이 잘못된 동작을 하는 것보다 더 어렵다|
|불필요한 복잡성(Needless complexity)|직접적인 효용이 전혀 없는 기반구조가 설계에 포함돼 있다|
|불필요한 반복(Needless repetition)|단일 추상 개념을 ㅗ통합할 수 있는 반복적인 구조가 설계에 포함돼 있다.|
|불투명성(Opacity)|읽고 이해하기 어렵다. 그 의도를 잘 표현하지 못한다|

<br>

##📌 경직성
소프트웨어가 경직되면 변경하기 어렵다. 변경 자체가 복잡하기 때문이 아니라 <u>그 변경으로 인해 발생하는 모든 후속 변경 사항이 일반적으로
예상한 것보다 많기 때문이다.</u>

더 나쁜 상황으로, 변경 후 영향을 받는 모든 기능을 수동으로 테스트 하지 않으면 시스템이 여전히 올바르게 동작하는지 확인 할 방법이 없을 수도 있다

크기가 작지 않은 애플리케이션이라면 이 작업이 상당히 어려울 것이다

<br>

##📌 취약성
<u>소프트웨어가 깨지기 쉬운 상태가 되면 변경사항이 간단하더라도 나머지 부분과 관련이 없더라도 변경으로 인해 예기치 않게 자주 중단 된다</u>

개발자는 의도치 않게 시스템을 손상 시킬 수 있으므로 기존 코드를 변경하는 것을 두려워하게 된다

깨지기 쉬운 시스템을 변경하면 시스템이 더 취약해지며 시스템의 복잡성은 해킹과 코드를 커버하는 코너 케이스로 인해 증가한다

<br>

##📌 불투명성
시스템이 불투명하면 코드를 읽기 어렵고 이해하기가 더 어려워진다. 이러한 시스템을 유지 관리하려면 명료하고 표현력 있는 코드를 사용하는 것 이상의 노력이 필요하다

<br>

##📌 부동성
재사용이 필요할 때 다른 시스템에서 재사용할 수 있는 코드를 만들기 위한 노력이 너무 크다는 것을 의미한다

<br>

> ###애자일 코드 설계 실천 방법

- **아키텍처 단계**
    - 어떤 종류의 애플리케이션을 만들지
    - 최상위 단계에서 시스템이 어떻게 동작할 지
    - 프로토 타입으로 만들어 설계한다
    
- **추상화 단계**
    - 인터페이스를 설계하여 인터페이스만 보고도 시스템이 내부적으로 어떻게 동작하는지 이해 할 수 있어야 한다
    
- **구현 단계**
    - 테스트 주도 개발 (Test Driven Development, TDD)
        - 구현 단계에서 테스트 주도 개발을 연습해야 한다. 이것은 <u>리팩터링을 수행한 후 작성한 코드가 올바르게 실행되는 지 확인하기 위해 이러한 단위
        테스트에 의존하기 때문에 애자일 프로젝트에서 중요하다. 또한 단위 테스트를 통해 소스 코드의 클라이언트로 사용해 코드 설계를 개선하고 분리할 수 있으며
        코드 품질을 개선하는 데 도움을 줄 수 있다. </u> 그리고 코드를 검증할 테스트 케이스가 있을 때 지저분한 코드를 정리하기 위해 리팩터링을 자주 수행하는
        시스템이 이전에 언급한 모든 증상을 겪지 않도록 할 수 있다
    
    - 인수 테스트 (Acceptance tests) = 사용자가 직접 하는 테스트
        - 단위 테스트 외에도 고객이 지정한 사용자 스토리의 세부사항을 확인하기 위해 인수 테스트를 작성해야 한다
        이러한 인수 테스트는 반복적을 실행 될 수 있어야 한다. 인수 테스트는 단위 테스트보다 높은 단계의 검증을 제공한다.
        단위 테스트와 인수 테스트는 함꼐 구현 단계의 설계를 검증하라고 리팩터링 하는 동안 자신감을 제공한다
        
    - 리팩터링 (Refactoring)
        - 몇 번 언급한 또 다른 관행은 리팩터링이다. 리팩터링은 집안의 가구를 재구성하거나 일이 지저분해지지 않도록 관리하는 것과 같다
        리팩터링은 필요할 때마다 디자인 원칙을 적용하거나 디자인 패턴을 사용하기 위해 코드를 변경해 설꼐를 개선하는 기술이다. 즉 코드를 작성할 때 단순하게
        시작해 테스트 케이스를 통과하는 데 필요한 코드만 작성하면 된다. 그 이상도 이하도 아니다. 이런 방식으로 구현 단계에서 간단한 설계를 유지하고
        코드에 변경 사항이나 악취가 있을 때만 리팩터링 한다
        
    - 현재 스토리 집중하기
        - 구현 단계에서 코드를 설계할 때 현재 스프린트의 사용자 스토리에 중점을 두고 가능하면 코드를 훌륭하게 설계해야 한다.
        미래의 사용자 스토리에 대해 너무 많은 걱정을 하지 말아야 한다. 이것을 명심하고 미래의 사용자스토리를 위한 코드를 작성하지 않는다 그 이유는 다음과 같다
        
            - 미래의 스토리는 변경되거나 버려질 수 있다. 미래의 스토리와 관련된 코드는 설계에 불필요한 복잡성을 초래 할 수 있다
            - 때가 되면 미래 스토리를 작성할 수 있다. 미래 스토리를 먼적 작성하는 것에는 큰 이정이 없다. 반대로 그것을 먼저 작성하면 위험을 안고 있는 것이나 마찬가지다 

<br>           

[README2 - SOLID 디자인 패턴](./README2.md)