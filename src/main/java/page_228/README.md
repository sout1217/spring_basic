# RestFul API

API는 api 공급자와 api 소비자 간의 계약이다.

REST는 간단하게 활용하고 이해하기 쉽기 때문에 가장 많이 활용되는 API 스타일 중 하나다.

REST 라는 용어는 2000년에 로이 필딩이 자신의 학술 논문에서 정의한 아키텍처 스타일인 REpresentational State Transfer를 나타낸다


RESTful 이라고 하는 많은 API는 실제로 RESTful 하지 않다.  RESTful 하다라는 것은 HTTP를 통한 JSON 이라고 잘못 생각하는 사람들이 있다

<br>

> ### RESTful API 특징

REST 아키텍처의 제약 조건을 준수하는 웹 서비스 API 를 RESTful API 라고 부른다.

- ###REST 아키텍처의 제약사항
    - 클라이언트-서버★
        - 이 제약사항은 관심사를 분리하는 것이다.
        - 사용자 인터페이스에 대한 관심사는 데이터 저장소의 관심사와 분리하는 것이다. 웹 애플리케이션은 이 스타일에 적합하다
        프론트엔드는 브라우저 내부에 클라이언트로 존재하며 클라이언트는 API를 통해 서버와 통신한다.
        - 잘 알려진 또 다른 아키텍처 스타일은 이벤트 기반의 통합 아키텍처다. 시스템의 구성 요소는 네트워크를 통해 이벤트를 전송하고 동시에 관심이 있는 이벤트를 수신한다
        
    - 무상태성 (쉽게 말해서 인증을 할 때 http session 방식은 피하라는 의미이다, jwt 권장)
        - 클라이언트와 서버 간의 통신은 무상태성(Stateless) 을 가진다. 클라이언트에서 서버로의 각 요청은 서버가 해당 요청을 이해하는 데
        저장된 컨텍스트를 이용해서는 안 된다.
        - 인증된 요청에 대해 서버 측면에 세션 ID 를 저장하는 시스템을 RESTful 이라고 부를 수 있는가???
        - [꼭 참고 하기](https://velog.io/@stampid/%EC%BF%A0%ED%82%A4-%EC%84%B8%EC%85%98-%EA%B7%B8%EB%A6%AC%EA%B3%A0-JWT)
        
    - 캐시
        - 이 제약 사항은 시스템 성능에 관련 된 것이며, 그 시스템에서 요청에 대한 응답에 암묵적 또는 명시적으로 캐시 가능 또는 캐시 불가능
        을 알려줄 수 있어야 한다. 웹 애플리케이션은 응답에서 Cache-control, ETag, Expireds 와 같은 HTTP 헤더를 사용해 캐시를 제어 할 수 있다.
        - [참고 사이트](https://www.zerocho.com/category/HTTP/post/5b594dd3c06fa2001b89feb9)
        
    - 유니폼 인터페이스
        - 이 제약사항은 REST 아키텍처 스타일을 SOAP 과 같은 다른 스타일과 구별하는 중심 기능이다.
        - 유니폼 인터페이스를 이용해 전반적인 시스템의 아키텍처가 단순화되고 상호작용의 가시성이 향상된다.
        - 유니폼 인터페이스를 얻는 데는 리소스 식별, 표현을 통한 리소스 조작, 자기 서술 메시지, 그리고 애플리케이션 상태의 엔지능로서의
        하이퍼미디어 등 네 가지 인터페이스 제약 사항이 있다.
        
    - 계층형 시스템
        - 관심사의 분리
        - 계층화된 시스템의 아키텍처는 구성 요소의 동작을 제한하는 계층으로 구성되어 각 구성 요소가 상호작용하는 밀접한 계층 너머로는 볼 수가 없다
    
    - 주문형 코드(Code-On-Demand)
        - 클라이언트는 리소스에 대한 표현을 응답으로 받고 처리해야 하는데, 어떻게 처리해야 하는 지에 대한 Code 를 서버가 제공하는 것을 의미한다.
        - HTML 에서의 javascript 가 가장 대표적인 예이다. 하지만 서버에서 제공되는 코드를 실행해야 하기 때문에 보안 문제를 야기할 수 있다.
        - 권장하지 않는 것으로 보인다. 액티브X같은 개념인거 같기도 하다
    
    - Restful 인터페이스 제약사항
        - 리소스 식별
            - REST 에서 리소스는 서비스에서 리소스를 클라이언트에게 제공할 수 있게 하는 정보를 추상화한 것이다.
            - 본질적으로 리소스는 사용자나 문서, 이미지, 작업일 수 있다.
            - 리소스는 URI 를 통해 고유하게 식별할 수 있어야 한다.
            - 예를들어 다음 URI 는 ID 가 1인 작업을 고유하게 식별한다
            `http://api.example.com/v1/tasks/1`
            - <u>보다시피 uri 에 버전 번호인 v1 을 추가한다</u>
            
        - 표현을 통한 리소스 조작
            - 리소스는 정보의 추상화라고 언급했다. 그것은 XML, HTML, JSON 과 같은 다른 형식을 가질 수 있는 표현을 통해 설명되는 상태를 갖는다
            - 최근에는 JSON 방식으로 표현한다
            - REST 에서 리소ㅓ스를 조작하는 것은 표준 HTTP 메소드(GET, POSTR, PATCH, DELETE)를 활용해 서버로 표현 형식(JSON) 을 보내는 것 이다
            
        - 자기 서술 메시지
            - REST 는 메시지가 자신을 어떻게 처리해야 할 지에 대한 정보를 포함하고 있어야 한다
            - 즉 수신자가 이해하기 위한 모든 정보를 가지고 있어야 한다
            - PUT 메소드는 데이터를 수정한다는 정보를 포함하고 있고, ContentType 은 표현형식 (JSON, XML) 정보를 포함하고 있다
            - [참고](http://amazingguni.github.io/blog/2016/03/REST%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4-1)
            
        - 애플리케이션 상태 엔진으로서의 하이퍼 미디어
            - 애플리케이션의 상태는 하이퍼미디어에 의해 변경된다는 의미이다.
            - `<a href="http://example.com/v2/task"/>`
            - `<form action="http://example.com/v2/task" method="POST"/>`
            
        - 리처드슨 성숙도 모델
            - 레벨 2 가 실용적이다 


> ### 고집스러운 RESTful API 특징

- 리소스 중심적
    - API 는 리소스를 중심으로 구성돼야 한다
    - `/member/insert/2` 처럼 행위가 표시되면 안된다는 것 같다 -> `/member/2`
- HTTP 메소드를 통한 작업 정의
    - 리소스에서 수행할 수 있는 작업은 HTTP 메소드를 통해 정의 행야 한다
    - GET
        - 리소스 조회
    - POST
        - 리소스 생성
    - PUT
        - 새로운 리소스 생성 또는 기존 리소스 수정
        - 이미 존재한 다면 해당 리소스로 대체 될 것이며, 그렇지 않으면 생성 될 것 이다
        - POST 와 차이점은 POST 는 `/v1/members` 처럼 식별자가 없지만, PUT 은 `/v1/members/1` 처럼 식별자가 붙는다
    - PATCH
        - 리소스의 일부내용만 수정
        - member 내용을 전체를 수정하는 것이 아닌, member 의 age 라던가, price 같은 일부내용만 수정할 때 사용한다
    - DELETE
        - 삭제
    
- 페이징 처리
    - offset 기반 (page 와 limit 을 이용한 방식)
        - `https://api.example.com/v/orders?page=1&count=20`
        - 단점 : 항목을 두 번 반환하거나 건너 뛸 수 있다.
            - 추가 될 때 : 1페이지당 10개 씩 보여준다고 가정하자. 1페이지를 다 보고 2페이지를 보려 클릭 한 순간 이미 그 전에 10개 데이터 새로 작성되서 1페이지의 데이터가 2페이지에 나오는 경우이다
            - 삭제 될 때 : 1페이지 보다 2페이지로 넘어갈 때 1페이지에서 삭제가 있다면 2페이지에 있던 내용이 1페이지로 넘어가면서 2페이지에 가도 그 항목은 못보게 된다
        
    - 커서 기반
        - 
            paging : {
                previous: https://api.example.com/v1/orders?count=20&before=101,
                next: https://api.example.com/v1/orders?count=20&before=120
            }
        - 이 방식 리소스의 id를 기반으로 작성되기 때문에 중복되거나 건너 뛰는 문제가 없다
        - 단점은 10페이지씩 50페이지씩 건너 뛸 수 없고 1페이지씩만 이동이 가능하다
        
- 검색과 정렬
    - API 는 일반적으로 컬렉션의 일부를 반환하기 위한 검색을 지원한다. 예를들어 당므은 완료된 주문만 가져오는 요청이다
    - [선호하는 방법] `https://api.example.com/v1/orders?status=completed`
    - [비선호하는 방법] `https://api.example.com/v1/orders/search?status=completed`
    - [완벽한 형태 - 가장 최근에 완료된 주문만 가져오기] `https://api.example.com/v1/orders?status=completed&sort=-completedDate`

- 보안
    - 무조건 SSL 을 사용해야한다 `https`
    - 사용자 이름, 비밀번호, 세션토큰, api 키는 URL 에 작성하지않고 Header 에 작성되어야 한다
    - **공개 API** 에서 사용하는 보안 방법
        - 첫번째 방법 (Random Token)
            - API 클라이언트가 랜덤으로 생성된 액세스 토큰을 HTTP 기본 인증의 username 필드 값으로 사용할 수 있도록 기본 HTTP 를 사용한 것이다
        - 두번째 방법 (OAuth2)
            - OAuth2 를 지원해 최종 사용자가 API 를 통해 최종 사용자의 데이터에 접근하려는 `서드 파티 애플리케이션`에 액세스 권한을 부여하는 것이다.
        - 세번째 방법 (JWT)
            - 위 2가지 방식이 효과가 없거나ㅣ 이상적이지 않을 때도 있다 그래서 JWT 토큰을 이용한다 (하지만 HTTP Session 을 대처하지는 못한다)
        
    - 내부 API 에서는 http session 을 이용한 보안인증 방식인 것이 좋다 (공개 api 는 대용량 트래픽이 될 수 있기 때문에 session 을 이용하며 서부 부하문제가 생긴다)
    
          
